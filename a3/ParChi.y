-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.3).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParChi
  ( happyError
  , myLexer
  , pExp1
  , pExp
  , pExp2
  , pBr
  , pListBr
  , pListExp
  , pListVariable
  ) where

import Prelude

import qualified AbsChi
import LexChi

}

%name pExp1 Exp1
%name pExp Exp
%name pExp2 Exp2
%name pBr Br
%name pListBr ListBr
%name pListExp ListExp
%name pListVariable ListVariable
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('           { PT _ (TS _ 1)           }
  ')'           { PT _ (TS _ 2)           }
  ','           { PT _ (TS _ 3)           }
  '->'          { PT _ (TS _ 4)           }
  '.'           { PT _ (TS _ 5)           }
  ';'           { PT _ (TS _ 6)           }
  '='           { PT _ (TS _ 7)           }
  '\\'          { PT _ (TS _ 8)           }
  'case'        { PT _ (TS _ 9)           }
  'of'          { PT _ (TS _ 10)          }
  'rec'         { PT _ (TS _ 11)          }
  '{'           { PT _ (TS _ 12)          }
  '}'           { PT _ (TS _ 13)          }
  L_Constructor { PT _ (T_Constructor $$) }
  L_Variable    { PT _ (T_Variable $$)    }

%%

Constructor :: { AbsChi.Constructor }
Constructor  : L_Constructor { AbsChi.Constructor $1 }

Variable :: { AbsChi.Variable }
Variable  : L_Variable { AbsChi.Variable $1 }

Exp1 :: { AbsChi.Exp }
Exp1
  : Exp1 Exp2 { AbsChi.Apply $1 $2 }
  | 'case' Exp 'of' '{' ListBr '}' { AbsChi.Case $2 $5 }
  | Exp2 { $1 }

Exp :: { AbsChi.Exp }
Exp
  : '\\' Variable '.' Exp { AbsChi.Lambda $2 $4 }
  | 'rec' Variable '=' Exp { AbsChi.Rec $2 $4 }
  | Exp1 { $1 }

Exp2 :: { AbsChi.Exp }
Exp2
  : Variable { AbsChi.Var $1 }
  | Constructor '(' ListExp ')' { AbsChi.Const $1 $3 }
  | '(' Exp ')' { $2 }

Br :: { AbsChi.Br }
Br
  : Constructor '(' ListVariable ')' '->' Exp { AbsChi.Branch $1 $3 $6 }

ListBr :: { [AbsChi.Br] }
ListBr
  : {- empty -} { [] }
  | Br { (:[]) $1 }
  | Br ';' ListBr { (:) $1 $3 }

ListExp :: { [AbsChi.Exp] }
ListExp
  : {- empty -} { [] }
  | Exp { (:[]) $1 }
  | Exp ',' ListExp { (:) $1 $3 }

ListVariable :: { [AbsChi.Variable] }
ListVariable
  : {- empty -} { [] }
  | Variable { (:[]) $1 }
  | Variable ',' ListVariable { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

